## ARC(Automatic Reference Counting)

#### ARC란?

- 자동 레퍼런스 카운팅으로서, 자동으로 메모리를 관리해주는 방식
- 참조 카운팅이 0이 될때만 메모리에서 해제
- 컴파일 시점에 동작

#### 동작 원리

- 클래스의 새로운 인스턴스 생성 시 ARC는 인스턴스의 정보를 저장하기 위해 메모리 할당
- 인스턴스가 더 이상 사용되지 않는다고 판단(참조 카운팅 0)하면 메모리 해제
- 레퍼런스 프로퍼티에 인스턴스를 할당하면 ARC는 참조되는 프로퍼티의 개수를 카운팅하여 참조하는 모든 변수가 인스턴스를 해제하기 전까지 인스턴스를 메모리에서 해제하지 않음

#### 장점

- 컴파일 당시 이미 인스턴스 해제 시점이 정해져 있어서 인스턴스가 언제 메모리에서 해제될지 예측 가능
- 컴파일 당시 이미 인스턴스 해제 시점이 정해져 있어서 메모리 관리를 위한 시스템 자원을 추가할 필요 없음

#### 단점

- ARC의 작동 규칙을 모르면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성 존재

  

## Weak VS Strong

#### Weak(약한 참조)

- 객체를 소유하지 않고 주소값만 가지고 있는 포인터 개념
- 자신이 참조는 하지만, weak 메모리 해제 권한은 다른 클래스에 있음
- 값 지정시 리테인, 릴리즈 발생 x -> 언제 어떻게 메모리가 해제되었는지 알 수 없음
- 따라서 weak 속성을 사용하는 객체는 항상 옵셔널 타입이어야 함
- 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않음
- 객체가 ARC에 의해 해제되면 nil값 할당
- [weak self]
  - ARC가 프로퍼티의 개수를 카운팅하지 않도록 만들며, 이로 인해 순환참조가 일어나지 않도록 만드는 역할
  - 그 이유는 weak 참조는 ARC에 의해 참조되는 인스턴스가 메모리에서 해제될 때 프로퍼티 값을 nil로 만들기 때문

#### Strong(강한 참조)

- 객체를 소유하여 레퍼런스 카운트가 증가하는 프로퍼티
- 값 지정 시점에 리테인이 되고, 참조가 종료되는 시점에 릴리즈됨
  - 레퍼런스 카운트를 증가시켜 ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용하고자 할 때 쓰임

#### + unowned

- 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않음
- 하지만 Non-Optional 타입으로 선언되어야 함
- 객체가 ARC에 의해 메모리 해제되어도 해당 객체 값을 존재하는 것으로 인지 -> 해당 객체에 접근하면 런타임 오류 발생
- 객체의 라이프 싸이클이 명확하고 개발자에 의해 제어 가능이 명확한 경우 weak 옵셔널 타입 대신 사용하여 간결한 코딩



## 타입 캐스팅에 사용하는 키워드 as

#### as

- 컴퍼일러가 타입 변환의 성공을 보장
- 컴파일 타임에 가능/불가능 여부 알 수 있음

#### as?

- 타입변환에 실패하는 경우 nil 리턴
- 컴파일 타임에 가능/불가능 여부 알 수 없음

#### as!

- 타입변환에 실패하는 경우 런타임 에러 발생
- 컴파일 타임에 가능/불가능 여부 알 수 없음



## Class VS Struct

#### Class

- 객체화시 힙 메모리 영역에 저장되며, ARC로 객체의 메모리 해제가 관리됨
- 대입 연산 시 레퍼런스가 복사되어 할당됨 (공유 가능)
- 상속 가능
- 멀티 스레딩 시 적절한 Lock활용 필요

#### Struct

- 대입 연산 시 값 자체가 복제되어 할당됨 (공유 불가)
- 불변성(Immutable) 구현에 유리
- 상속 불가능 (프로토콜은 사용 가능)
- 멀티스레딩에 안전함



## Frame VS Bounds

#### Frame 

- SuperView 좌표 시스템 내에서 view의 위치(origin)와 크기(size)

###### Bounds

- view 자기 자신의 좌표 시스템에서의 위치와 크기

- 부모뷰와의 위치관계와는 아무런 상관 x

- 자기 자신의 좌표시스템을 가리키기 때문에 기본적으로 origindms x:0 y:0

- ScrollView/TableView등을 스크롤할 때 ScrollView/TableView.bounds가 변하고, subview 들이 그려지는 위치가 달라지는 것 -> subview의 Frame이 달라지는 것이 아님 

  

## UICollectionViewLayout 클래스에 Prepare의 역할

- 레이아웃관련 연산이 일어날 때마다 가장 먼저 호출
- 이 메소드에서 셀의 위치/크기 등을 계산하기 위한 사전처리
- UICollectionViewLayout 를 상속받아 Custom 한 CollectionView Layout 을 구성하고자 할때, 데이터소스를 참조하여 셀의 위치 및 크기를 미리 계산하여 캐싱해두고, CollectionView 로부터 셀의 위치 및 크기 요청이 들어올때, 미리 계산하여 캐싱해둔 데이터를 전달해주는 방식으로 커스텀 레이아웃을 구성하는 방식이 있음

#### 

## View Controller 생명주기

- **loadView ** 

  - 컨트롤러가 관리하는 뷰를 만든다. 뷰컨트롤러가 생성되고 순차적으로 완성되었을때만 호출

- **viewDidLoad ** 

  - 컨트롤러의 뷰가 메모리에 올라간 뒤에 호출된다. 뷰가 생성될때만 호출

- **viewWillAppear **

  -  화면에 뷰가 표시될때마다 호출 
  - 이 단계는 뷰는 정의된 바운드를 가지고 있지만 화면회전은 적용되지 않음

- **viewWillLayoutSubviews** 

  - 뷰컨트롤러에게 그 자식뷰의 레이아웃을 조정하는 것에 대한 것을 알려주기위해 호출 
  - 이 메소드는 frame이 바뀔때마다 호출

- **viewDidLayoutSubviews ** 

  - 뷰가 그 자식 뷰의 레이아웃에 영향을 준 것을 뷰컨트롤러에게 알려주기 위해 호출
  - 뷰가 그 자식 View의 레이아웃을 바꾸고난 뒤에 추가적인 변경을 하고 싶을때 사용하는 이벤트 함수

- **viewDidAppear ** 

  - 뷰가 나타났다는 것을 컨트롤러에게 알리는 역할
  - 호출되는 시점으로는 뷰가 화면에 나타난 직후에 실행

- **viewWillDisAppear ** 

  - 뷰가 사라지기 직전에 호출되는 함수
  - 뷰가 삭제 되려고하고있는 것을 ViewController에게 알림

- **viewDidDisappear **

  - viewWillDisAppear 다음에 호출

  - ViewController에게 View가 제거되었음을 알림 



## App의 생명 주기

- **application(_:didFinishLaunching:)** - 앱이 처음 시작될 때 실행
- **applicationWillResignActive**: - 앱이 active 에서 inactive로 이동될 때 실행
- **applicationDidEnterBackground**: - 앱이 background 상태일 때 실행
- **applicationWillEnterForeground**: - 앱이 background에서 foreground로 이동 될때 실행 (아직 foreground에서 실행중이진 않음)
- **applicationDidBecomeActive**: - 앱이 active상태가 되어 실행 중일 때
- **applicationWillTerminate**: - 앱이 종료될 때 실행 



## 동기 VS 비동기

#### Synchonize(동기)

- 주어진 명령을 차례로 처리하되 하나의 업무가 완료되기 전 다른 업무로 넘어가지 않음
- 중간에 대기하는 시간으로 효율은 떨어지지만, 일관된 업무 보장과 동시다발적 업무 발생 x -> 대응이 불필요하여 업무 구성 단순화

#### Asynchonize(비동기)

- 주어진 명령을 차례로 처리하되 시간이 걸리는 업무는 진행해둔 채 기다리는 동안 다른 업무 처리하는 방식
- 일관적인 업무 흐름이 깨지고, 응답에 대한 대응이 필요



## 스레드

- 하나의 프로세스 내에서 실행되는 작업흐름의 단위
- 메인 스레드 : 프로세스가 시작하는 동시에 동작하는 스레드
- 서브 스레드 : 이외의 추가로 생성되는 스레드
- 멀티 스레드 
  - 여러 개의 스레드가 동시에 진행
  - 하나의 프로세스 내에서 여러 개의 스레드가 존재
  - 스레드들이 프로세스의 자원을 공유하되 실행은 독립적으로 이루어지는 구조



## 프레임워크

- 다양한 클래스들을 비슷한 범주의 클래스들끼리 묶어놓은 것
- ex) UIkit..
- 더 큰 범주는 IOS운영체제
- IOS 운영체제 계층
  - **Cocoa Touch**
    - IOS 앱에 사용자 인터페이스(UI) 관련 계층
    - UIKit, MapKit, Message UI 등의 프레임워크
    - 스토리보드, 오토 레이아웃, 제스처 인식, 애플 푸시 알림 기능 등을 여기서 담당
  - **Media**
    - 2D, 3D 그래픽 애니메이션 이미지 효과, 오디오, 비디오 기능 담당
    - Core Graphics, AVKit(동영상 재생), Metal(하드웨어 가속 그래픽 연산 기능) 프레임워크
  - **Core Service**
    - 사용자의 인터페이스와는 직접적인 관련 x
    - Core OS와 관련
    - Core Data(데이터 베이스와 비슷), Foundation(하위 계층 시스템이나 서비스에 접근할 수 있는 유틸리티 클래스), Core Foundation 프레임워크
    - 데이터 관리, Int와 String 등의 자료형, 
  - **Core OS**
    - 하드웨어에 가장 근접한 Low Level의 계층
    - Accelerate, OpenCL, SystemConfiguration 프레임워크
      - Accelerate : 하드웨어 가속, 이미지나 비디오 프로세싱, 데이터 병렬처리 등 앱 성능향상 제공
      - OpenCL : CPU와 GPU에서 병렬처리를 도와줌
      - SystemConfiguration : 앱에서 네트워크 연결 도움
      - 커널 : 파일 시스템, 네트워크
    - 앱에서 직접 접근하지는 않지만 상위 다른 계층에서 대부분 사용하는 프레임워크
    - 병렬처리, 보안(App SandBox), Code Signing, 파일 시스템, 네트워크
    - App SandBox : 앱의 접근 권한을 특정 폴더로 한정해서 악성코드로 부터 사용자 데이터 및 시스템에 대한 최후의 방어선 구축
    - Code Signing : 앱 인증관련 보안 기술, 악의적인 코드로 인한 앱의 변경사항 감지 가능

- developer.apple.com -> Develop -> Documentation에서 다양한 프레임워크 확인 가능
- 다양한 프레임워크를 import해서 사용 가능
- IOS 버전이 올라갈 때마다 새로운 프레임워크 클래스가 추가되어 이미 구현되어 있는 api 사용
  - 당연히 버전이 낮으면 특정 기능을 사용할 수 없을 수 있음



## 접근 제어(Access Control)

#### open 

- 정의된 모듈외에서도 접근 가능

- 모든 접근수준 중 open만이 모듈 밖의 다른 모듈에서 상속 가능 (클래스)
- 모든 접근수준 중 open으로 선언된 클래스의 멤버(프로퍼티, 메소드)들만이 다른 모듈에서 override 가능
  - ex) UIViewController

#### public 

- open과 마찬가지로, 정의된 모듈외에서도 접근 가능
- 외부에서 생성은 할 수 있으나 override가 불가능 하다는 점에서 open과 차이

#### internal 

- 안드로이드에서 default
- 같은 모듈 내에서는 어디서든 접근 가능하며 클래스의 경우 상속 가능

#### fileprivate 

- 하나의 swift 파일 내부에서만 접근이 가능한 접근제어 수준
- 같은 모듈 내 어디서든 접근 가능하며 클래스의 경우 상속 가능

#### private 

- 그 요소가 선언된 영역(블록)내에서만 접근 가능

#### 특징

- 외부 요소의 접근제어 수준보다 높은 수준의 내부 요소는 있을 수 없음
  - 클래스의 접근수준이 private 이면 클래스의 멤버들은 public, internal 등 private보다 상위 수준의 접근수준이 될 수 없고 선언이 되어도 private으로 취급
- 특정 접근제어 수준의 타입이 함수의 매개변수나 반환되는 타입일 경우 함수는 해당 값은 접근제어보다 높을 수 없음
  -  메소드나 함수가 public한데 private한 매개변수를 받거나 private한 값을 반환하는 것은 상식적으로 맞지 않음. 
  -  이때 매개변수의 타입이나 반환되는 값의 접근제어 수준은 메소드나 함수의 접근제어 수준과 같거나 높아야 함